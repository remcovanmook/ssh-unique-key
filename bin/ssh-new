#!/bin/bash
set -e

# Get the directory this script is running from
SCRIPT_DIR=$(dirname "$0")
# shellcheck source=./_ssh-unique-key.inc.sh
source "${SCRIPT_DIR}/_ssh-unique-key.inc.sh"
ensure_base_dirs

# --- Argument Parsing ---
VERBOSE=false
TEMPLATE_NAME=""
POSITIONAL_ARGS=()

while [[ "$#" -gt 0 ]]; do
    case $1 in
        -v|--verbose) VERBOSE=true; shift ;;
        --template) TEMPLATE_NAME="$2"; shift 2 ;;
        *) POSITIONAL_ARGS+=("$1"); shift ;;
    esac
done

if [ ${#POSITIONAL_ARGS[@]} -ne 1 ]; then
    err "Usage: ssh-new [-v] [--template <name>] <user@host>"
fi
USER_HOST_ARG="${POSITIONAL_ARGS[0]}"

log() {
    if [ "$VERBOSE" = true ]; then
        echo "$@"
    fi
}

HOST_NAME=$(get_host_from_arg "$USER_HOST_ARG")
USER_NAME=$(get_user_from_arg "$USER_HOST_ARG")

# --- Host Key Scan and Verification ---
log "Scanning host $HOST_NAME..."
RAW_SCAN_DATA=$(get_full_host_scan "$HOST_NAME")
# Create the canonical, sorted version for storage and comparison
SCAN_DATA_SORTED=$(echo "$RAW_SCAN_DATA" | sort)

HOST_UUID=$(get_host_uuid_from_scan_data "$SCAN_DATA_SORTED")
CANONICAL_PATH="$UUID_DIR/$HOST_UUID"


if [ -d "$CANONICAL_PATH" ]; then
    log "Host identity already exists. Verifying keys..."
    EXISTING_HOST_IDENTITY=true
    STORED_KEYS_FILE="$CANONICAL_PATH/known_host_keys"
    
    # Compare sorted new scan with the (already sorted) stored file
    # Compare sorted new scan with the stored file, IGNORING the hostname field
    # (fields 2 and 3 are algorithm and key)
    NEW_KEYS_CONTENT=$(echo "$SCAN_DATA_SORTED" | awk '{print $2, $3}' | sort)
    STORED_KEYS_CONTENT=$(cat "$STORED_KEYS_FILE" | awk '{print $2, $3}' | sort)
    
    if ! diff -q <(echo "$NEW_KEYS_CONTENT") <(echo "$STORED_KEYS_CONTENT") >/dev/null; then
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
        echo "  @       WARNING: HOST KEY CHANGED!       @" >&2
        echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" >&2
        err "Host key verification failed."
    else
        log "Host keys verified successfully."
    fi
else
    # Only echo this important state change if verbose, OR maybe meaningful enough to keep? 
    # User requested reduced verbosity. Let's log it.
    log "New host key detected. Creating new identity."
    mkdir -p -m 700 "$CANONICAL_PATH"
    # Store the sorted, canonical data
    echo "$SCAN_DATA_SORTED" > "$CANONICAL_PATH/known_host_keys"
    chmod 644 "$CANONICAL_PATH/known_host_keys"

    log "Stored host keys in $CANONICAL_PATH/known_host_keys"
fi

# --- Create User Key (if needed) ---
USER_KEY_DIR="$CANONICAL_PATH/$USER_NAME"
mkdir -p -m 700 "$USER_KEY_DIR"
KEY_FILE="$USER_KEY_DIR/identity"
KEY_FILE_PUB="$USER_KEY_DIR/identity.pub"
TEMPLATE_CONFIG_PATH=""
KEY_GEN_TYPE=""

if [ ! -f "$KEY_FILE" ]; then
    if [ -n "$TEMPLATE_NAME" ]; then
        # --- TEMPLATE LOGIC ---
        PRIORITY_LIST=("ed25519" "ecdsa" "rsa")
        TEMPLATE_PATH_BASE="$TEMPLATE_DIR/$TEMPLATE_NAME"
        [ ! -d "$TEMPLATE_PATH_BASE" ] && err "Template '$TEMPLATE_NAME' not found."
        
        TEMPLATE_CONFIG_PATH="$TEMPLATE_PATH_BASE/config"

        for key_type in "${PRIORITY_LIST[@]}"; do
            if echo "$SCAN_DATA_SORTED" | grep -q "$key_type"; then
                if [ -f "$TEMPLATE_PATH_BASE/id_$key_type" ]; then KEY_GEN_TYPE="$key_type"; break; fi
            fi
        done
        [ -z "$KEY_GEN_TYPE" ] && err "No compatible keys found in template '$TEMPLATE_NAME'."

        log "Linking best common key ($KEY_GEN_TYPE) as 'identity'..."
        TEMPLATE_KEY_REL_PATH="../../templates/$TEMPLATE_NAME/id_$KEY_GEN_TYPE"
        (cd "$USER_KEY_DIR" && \
         ln -s "$TEMPLATE_KEY_REL_PATH" "identity" && \
         ln -s "$TEMPLATE_KEY_REL_PATH.pub" "identity.pub")
    else
        # --- NEW KEY GENERATION LOGIC ---
        KEY_GEN_TYPE=$(get_best_key_type_from_scan_data "$SCAN_DATA_SORTED")
        log "Generating new $KEY_GEN_TYPE key as 'identity'..."
        
        declare -a KEYGEN_ARGS
        if [ "$KEY_GEN_TYPE" == "rsa" ]; then
            KEYGEN_ARGS=("-b" "4096")
        fi
        
        ssh-keygen -t "$KEY_GEN_TYPE" -f "$KEY_FILE" \
            -N "" -C "$USER_NAME@$HOST_NAME" "${KEYGEN_ARGS[@]}"
        chmod 600 "$KEY_FILE"; chmod 644 "$KEY_FILE_PUB"
    fi
fi

# --- Create Host Config File (with template inheritance) ---
HOST_CONFIG_FILE="$CANONICAL_PATH/config"
if [ ! -f "$HOST_CONFIG_FILE" ]; then
    touch "$HOST_CONFIG_FILE"
    chmod 600 "$HOST_CONFIG_FILE"
    
    if [ -n "$TEMPLATE_CONFIG_PATH" ] && [ -f "$TEMPLATE_CONFIG_PATH" ]; then
        # Get absolute path for the Include directive
        ABS_TEMPLATE_CONFIG_PATH=$(cd "$(dirname "$TEMPLATE_CONFIG_PATH")" && pwd)/$(basename "$TEMPLATE_CONFIG_PATH")
        echo "# Inherits from template: $TEMPLATE_NAME" > "$HOST_CONFIG_FILE"
        echo "Include $ABS_TEMPLATE_CONFIG_PATH" >> "$HOST_CONFIG_FILE"
        echo "" >> "$HOST_CONFIG_FILE"
        echo "# Add host-specific overrides below" >> "$HOST_CONFIG_FILE"
    fi
fi

# --- Copy Key to Host (This populates known_hosts) ---
# Only run ssh-copy-id if we didn't just verify an existing identity
# (Assume existing identity means we've been here before)
if [ "$EXISTING_HOST_IDENTITY" = false ]; then
    log "Copying public key to $USER_HOST_ARG (password may be required)..."
    ssh-copy-id -i "$KEY_FILE_PUB" "$USER_HOST_ARG"
fi

# --- Create by-host Symlink ---
HOST_SYMLINK_PATH="$HOST_DIR/$HOST_NAME"
if [ ! -L "$HOST_SYMLINK_PATH" ]; then
    log "Creating by-host symlink..."
    ln -s "$CANONICAL_PATH" "$HOST_SYMLINK_PATH"
fi

# --- Create ALL by-key Symlinks ---
log "Creating by-key symlinks for all host keys..."
# Use the *unsorted* raw data to get the base64 keys
echo "$RAW_SCAN_DATA" | while read -r line; do
    [ -z "$line" ] && continue
    # The 3rd field is the base64 key
    BASE64_KEY=$(echo "$line" | awk '{print $3}')
    [ -z "$BASE64_KEY" ] && continue
    
    KEY_SYMLINK_PATH="$KEY_DIR/$BASE64_KEY"
    KEY_SYMLINK_DIR=$(dirname "$KEY_SYMLINK_PATH")
    
    mkdir -p -m 700 "$KEY_SYMLINK_DIR"
    # Symlink points to the host-uuid *directory*
    ln -sf "$CANONICAL_PATH" "$KEY_SYMLINK_PATH"
    log "  -> $KEY_SYMLINK_PATH"
done

# --- Connect to host ---
log "Done. Connecting to $USER_HOST_ARG..."
exec ssh "$USER_HOST_ARG"